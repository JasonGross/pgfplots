%--------------------------------------------
%
% Package pgfplots
%
% Provides a user-friendly interface to create function plots (normal
% plots, semi-logplots and double-logplots).
% 
% It is based on Till Tantau's PGF package.
%
% Copyright 2010 by Nick Papior Andersen.
%
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.
%
%--------------------------------------------

\newif\ifpgfplots@contour@calc@linear
\pgfplots@contour@calc@lineartrue
\newif\ifpgfplots@contour@process
\newif\ifpgfplots@contour@first@point

\usetikzlibrary{calc}

\pgfkeys{
    /pgfplots/contour/.is family,
    /pgfplots/calculation method/.is choice,
    /pgfplots/calculation method/linear/.is if=\ifpgfplots@contour@calc@linear,
    /pgfplots/contour/levels/.store in=\pgfplots@contour@levels,
}

% My custom PRIORITY logger.
% This is to the pgfplotstest.contour.log, and should only be used together with the test case
%\def\wcontour#1#2{\ifnum#1<6\immediate\write\pgfplotscontourstream{#2}\fi}
% this is the default logger to the log.
\def\wcontour#1#2{\ifnum#1<6\wlog{#2}\fi}

\newcount\c@pgfplots@tmp
\newcount\c@pgfplots@row
\newcount\c@pgfplots@col
\newcount\c@pgfplots@contour@row@f
\newcount\c@pgfplots@contour@col@f
\newcount\c@pgfplots@contour@edge@loop
\newcount\c@pgfplots@contour@start@edge
\def\pgfplots@contour@runned@mark{x}
\def\pgfplots@contour@start{%
    %
    % Obtain the size of the data matrix
    %
    \pgfplotsmatrixsize\pgfplots@data@matrixX\to\c@pgfplots@row\c@pgfplots@col
    \advance\c@pgfplots@row by-2
    \advance\c@pgfplots@col by-2
    \edef\c@pgfplots@row@end{\the\c@pgfplots@row}
    \edef\c@pgfplots@col@end{\the\c@pgfplots@col}
    \advance\c@pgfplots@row by1
    \advance\c@pgfplots@col by1
    \wcontour1{Starting the contour calculation with size \c@pgfplots@row@end,\c@pgfplots@col@end}
    %
    % Determine the right calculation method
    %
    \ifpgfplots@contour@calc@linear
      \wcontour{20}{Setting the contour calculation to use the linear method.}
      \let\pgfplots@contour@calc@method=\pgfplots@contour@calc@linear
    \fi
    %
    % This matrix will hold every point and see that it has been checked.
    %
    \pgfplotsmatrixnewempty\pgfplots@contour@matrix@runned
    \pgfplotsmatrixresize\pgfplots@contour@matrix@runned\c@pgfplots@row@end\c@pgfplots@col@end
    % 
    % The list which holds the levels has been giving.
    \expandafter\pgfplotsarraynew\expandafter\pgfplots@contour@levels@array\expandafter{\pgfplots@contour@levels}
    \edef\pgfplots@contour@lvls{\pgfplotsarraysizeof\pgfplots@contour@levels@array}
    \pgfplotsmatrixnewempty\pgfplots@contour@matrix@points
    % 
    % Only start with 1 rows and a 2 column matrix. Build up as in Matlab
    % and Octave etc.
    % Matrix m:
    % -------
    % m(0,0) = number of elements in first contour
    % m(0,1) = contour value of first contour
    % m(m(0,0),0) = number of elements in second contour
    % m(m(0,0),1) = contour value of second contour
    % 
    % Only in our case we will build it up reversibly.
    % This makes it easier to handle as one does not need to count and reset in the end.
    % TODO consider changing this
    % 
    \pgfplotsmatrixresize\pgfplots@contour@matrix@points{1}{2}
    %
    % In the end we resize the matrix to its real size! The resize does not change any elements.
    % Only the information regarding the size.
    %
    \let\c@pgfplots@contour@level=\c@pgf@countc
    \let\c@pgfplots@contour@cur=\c@pgf@countd
    \let\pgfplots@contour@run=\relax
    \c@pgfplots@contour@level=0
    \c@pgfplots@contour@cur=0
    \edef\c@pgfplots@contour@cur@init{\the\c@pgfplots@contour@cur}
    \pgfplotsloop{%
        \ifnum\c@pgfplots@contour@level<\pgfplots@contour@lvls\relax
          \pgfplotsloopcontinuetrue
        \else
          \pgfplotsloopcontinuefalse
        \fi
    }{%
        %
        % As we use this loop over the levels we have to reset the "runned" matrix.
        % For very large arrays it could be better so make a list in each point which states which contours it has passed
        % Currently it is very inconvenient for very large arrays.
        %
        \pgfplots@contour@reset@runned%
        \pgfplotsarrayselect{\the\c@pgfplots@contour@level}\of\pgfplots@contour@levels@array\to\pgfplots@contour@curlevel
        \wcontour3{ 1. Running the array at \the\c@pgfplots@contour@level\space with value \pgfplots@contour@curlevel}
        \pgfplots@contour@calc@method%
        % start the contour if required, this will also recheck the number of contour points and update the list accordingly.
        \pgfplots@contour@start@contour 
        \advance\c@pgfplots@contour@level by1
    }
    %
    % We now have informed pgfplots of the genuine size of the matrix which holds the contours.
    \pgfplotsmatrixresize\pgfplots@contour@matrix@points{\the\c@pgfplots@contour@cur}{2}%
}

\def\pgfplots@contour@calc@linear{%
    \wcontour{10}{Linear contour calc now.}
    \c@pgfplots@col=-1%
    \c@pgfplots@row=0%
    \pgfplotsloop{%
        \ifnum\the\c@pgfplots@col=\c@pgfplots@col@end\relax
          \ifnum\the\c@pgfplots@row=\c@pgfplots@row@end\relax
            \pgfplotsloopcontinuefalse%
          \else
            \advance\c@pgfplots@row by1
            \c@pgfplots@col=-1
            \pgfplotsloopcontinuetrue
          \fi%
        \else%
          \pgfplotsloopcontinuetrue%
        \fi%
        \advance\c@pgfplots@col by1%
    }{%
        \wcontour7{Started linear findings with (\the\c@pgfplots@row,\the\c@pgfplots@col) of (\c@pgfplots@row@end,\c@pgfplots@col@end) }%
        % 
        % Begin calculation of the contour, this is not the best implementation but it should work.
        % The wrong doing is looping through the entire matrix for each contour level. This is O(N)*lvls
        % 
        % If the matrix element has already been processed then just continue.
        % 
        % \edef\pgfplots@contour@tmpA{%
        %     \noexpand\pgfplotsmatrixvalueofelem\the\c@pgfplots@row,\the\c@pgfplots@col\noexpand\of\noexpand\pgfplots@contour@runned}
        \pgfplots@contour@first@pointtrue
        \pgfplots@contour@read@runned(\the\c@pgfplots@row,\the\c@pgfplots@col)\to\pgfplots@contour@tmpA
%        \edef\pgfplots@contour@tmpA{\csname\string\pgfplots@contour@matrix@runned@\the\c@pgfplots@row,\the\c@pgfplots@col\endcsname}
        \ifx\pgfplots@contour@tmpA\pgfplots@contour@runned@mark
          \wcontour1{ 1.1: Has been runned! \pgfplots@contour@tmpA}
        \else
          \wcontour1{ 1.1: Checked in main loop for \pgfplots@contour@tmpA}
        % I can now call \pgfplots@contour@calc@linear@
        % Use a temporary command to call after. This ensures that we do not have endless groups! This command gets defined in
        % Thus \pgfplots@contour@follow@contours will be called afterwards.
        % If it has been redefined to follow a contour it will carry on.
          \pgfplots@contour@calc@linear@{\the\c@pgfplots@row}{\the\c@pgfplots@col}{-1}
          % Remember to finish of the contour now!
          % Ex. \pgfplots@contour@follow@contours
          % Needs to be called out here due to the limitation of nested calls
          % Note, maybe the pgfplots@contourloop is not prone to this. It isn't infinitely nested and as such there should be no problem?
          \ifx\pgfplots@contour@follow@contours\relax
          \else
            \wcontour2{ 1.2: FOLLOW(\the\c@pgfplots@contour@edge@loop) at (\the\c@pgfplots@row,\the\c@pgfplots@col)}
          \fi
          \pgfplots@contour@follow@contours
        \fi%
    }%
}%

%
% This command is called by:
% \pgfplots@contour@calc@linear@<row><col><start edge>
% The startedge parameter is used to figure out where the contour came from. A negative value would
% show the macro that it is the first point.
% 
\def\pgfplots@contour@calc@linear@#1#2#3{%
    \let\pgfplots@contour@follow@contours=\relax
    \pgfplots@contour@read@runned(#1,#2)\to\pgfplots@contour@tmpA
    \wcontour2{ 1.1.1 Calculating with data: (#1,#2) with edge: #3 at the level \pgfplots@contour@curlevel. Run=\pgfplots@contour@tmpA}
    % 
    % Mark it as runned
    % I am not using the \pgfplotsmatrixset due to speed!
    \pgfplots@contour@mark@runned(#1,#2)
    % 
    % As the next two nested ifs consider if we should run the point we have to force the 
    % processing and disable it if necessary.
    \pgfplots@contour@processtrue
    % 
    % First retreive the X and Y points in the quadro point segment of the current row and column.
    %
    \pgfplots@matrix@get@offset#1,#2\offset1,0\of\pgfplots@data@matrixX\to{\pgfplots@contour@0@X}
    \pgfplots@matrix@get@offset#1,#2\offset0,0\of\pgfplots@data@matrixX\to{\pgfplots@contour@1@X}
    \pgfplots@matrix@get@offset#1,#2\offset0,1\of\pgfplots@data@matrixX\to{\pgfplots@contour@2@X}
    \pgfplots@matrix@get@offset#1,#2\offset1,1\of\pgfplots@data@matrixX\to{\pgfplots@contour@3@X}
    %
    \pgfplots@matrix@get@offset#1,#2\offset1,0\of\pgfplots@data@matrixY\to{\pgfplots@contour@0@Y}
    \pgfplots@matrix@get@offset#1,#2\offset0,0\of\pgfplots@data@matrixY\to{\pgfplots@contour@1@Y}
    \pgfplots@matrix@get@offset#1,#2\offset0,1\of\pgfplots@data@matrixY\to{\pgfplots@contour@2@Y}
    \pgfplots@matrix@get@offset#1,#2\offset1,1\of\pgfplots@data@matrixY\to{\pgfplots@contour@3@Y}
    % 
    % There is an error parsing the point which does not exist. We correct this by subtracting one from the row and col end
    \pgfplots@matrix@get@offset#1,#2\offset1,0\of\pgfplots@data@matrixZ\to{\pgfplots@contour@0@tmp}
    \pgfmathsubtract{\pgfplots@contour@get@macro0{tmp}}{\pgfplots@contour@curlevel}
    \expandafter\edef\csname\string\pgfplots@contour@0@Z\endcsname{\pgfmathresult}
    \pgfplots@matrix@get@offset#1,#2\offset0,0\of\pgfplots@data@matrixZ\to{\pgfplots@contour@0@tmp}
    \pgfmathsubtract{\pgfplots@contour@get@macro0{tmp}}{\pgfplots@contour@curlevel}
    \expandafter\edef\csname\string\pgfplots@contour@1@Z\endcsname{\pgfmathresult}
    \pgfplots@matrix@get@offset#1,#2\offset0,1\of\pgfplots@data@matrixZ\to{\pgfplots@contour@0@tmp}
    \pgfmathsubtract{\pgfplots@contour@get@macro0{tmp}}{\pgfplots@contour@curlevel}
    \expandafter\edef\csname\string\pgfplots@contour@2@Z\endcsname{\pgfmathresult}
    \pgfplots@matrix@get@offset#1,#2\offset1,1\of\pgfplots@data@matrixZ\to{\pgfplots@contour@0@tmp}
    \pgfmathsubtract{\pgfplots@contour@get@macro0{tmp}}{\pgfplots@contour@curlevel}
    \expandafter\edef\csname\string\pgfplots@contour@3@Z\endcsname{\pgfmathresult}
    %
    % \pgfplots@tmpa % tmp counter
    \pgfplots@contour@calc@edge@prod{\pgfplots@contour@0@Z}{\pgfplots@contour@1@Z}\to{\pgfplots@contour@0@edge}
    \pgfplots@contour@calc@edge@prod{\pgfplots@contour@1@Z}{\pgfplots@contour@2@Z}\to{\pgfplots@contour@1@edge}
    \pgfplots@contour@calc@edge@prod{\pgfplots@contour@2@Z}{\pgfplots@contour@3@Z}\to{\pgfplots@contour@2@edge}
    \pgfplots@contour@calc@edge@prod{\pgfplots@contour@3@Z}{\pgfplots@contour@0@Z}\to{\pgfplots@contour@3@edge}
    % 
    \edef\pgfplots@contour@tmpA{%
        \noexpand\wcontour6{%
            0=\pgfplots@contour@get@macro0{edge} (\pgfplots@contour@get@macro0X,\pgfplots@contour@get@macro0Y,\pgfplots@contour@get@macro0Z) at (#1,#2)
        }
        \noexpand\wcontour6{%
            1=\pgfplots@contour@get@macro1{edge} (\pgfplots@contour@get@macro1X,\pgfplots@contour@get@macro1Y,\pgfplots@contour@get@macro1Z)
        }
        \noexpand\wcontour6{%
            2=\pgfplots@contour@get@macro2{edge} (\pgfplots@contour@get@macro2X,\pgfplots@contour@get@macro2Y,\pgfplots@contour@get@macro2Z)
        }
        \noexpand\wcontour6{%
            3=\pgfplots@contour@get@macro3{edge} (\pgfplots@contour@get@macro3X,\pgfplots@contour@get@macro3Y,\pgfplots@contour@get@macro3Z)
        }
    }\pgfplots@contour@tmpA
    % 
    % Check if we should at all process the current point?
    \ifnum\pgfplots@contour@get@macro0{edge}=\pgfplots@contour@get@macro1{edge}
      \ifnum\pgfplots@contour@get@macro2{edge}=\pgfplots@contour@get@macro3{edge}
        \ifnum\pgfplots@contour@get@macro1{edge}=\pgfplots@contour@get@macro2{edge}
          \ifnum\pgfplots@contour@get@macro0{edge}=-1
            % We are in the case of all edges the same and with value -1
            \wcontour4{ 1.1.3 All edges are below or over the contour. INVALID}
            \pgfplots@contour@processfalse
          \fi
        \fi
      \fi
    \fi
    % This below test probably have errors when numbers are close to zero but not exactly. Maybe it should use the fpu lib?
    % it is because the Z points have data like 0.9... So the = sign is never found as ifnum only checks for integers
    \pgfplots@contour@check@zero\pgfplots@contour@get@macro0Z\to\pgfplots@contour@tmpA
    \ifnum\pgfplots@contour@tmpA=0
      \pgfplots@contour@check@zero\pgfplots@contour@get@macro1Z\to\pgfplots@contour@tmpA
      \ifnum\pgfplots@contour@tmpA=0
        \pgfplots@contour@check@zero\pgfplots@contour@get@macro2Z\to\pgfplots@contour@tmpA
        \ifnum\pgfplots@contour@tmpA=0
          \pgfplots@contour@check@zero\pgfplots@contour@get@macro3Z\to\pgfplots@contour@tmpA
          \ifnum\pgfplots@contour@tmpA=0
            % We are in the case of all edges the same and with value 0
            \wcontour4{ 1.1.3 All edges are on the contour, i.e. a flat square. INVALID}
            \pgfplots@contour@processfalse
          \fi
        \fi
      \fi
    \fi
    % 
    % So now we have tested whether or not we should process the point.
    % Loop over the edges
    %
    \ifpgfplots@contour@process
      \c@pgfplots@contour@edge@loop=-1
      \ifnum#3<0
        \edef\c@pgfplots@contour@edge{1}
      \else
        \pgfmathadd{#3}{1}%
        \pgfmathint{\pgfmathresult}%
        \edef\c@pgfplots@contour@edge{\pgfmathresult}
      \fi
      % Comparing with contour.c we have :
      % \c@pgfplots@contour@edge@loop = k
      % \c@pgfplots@contour@edge      = i
      \wcontour{10}{ 1.1.4 Just before calc loop \the\c@pgfplots@contour@edge@loop\space and \c@pgfplots@contour@edge}
      \pgfplotsloop@contour{%
          \ifnum\c@pgfplots@contour@edge=0
            \edef\c@pgfplots@contour@edge{3}
          \else
            \pgfmathsubtract{\c@pgfplots@contour@edge}{1}%
            \pgfmathint{\pgfmathresult}%
            \edef\c@pgfplots@contour@edge{\pgfmathresult}%
          \fi%
          \advance\c@pgfplots@contour@edge@loop by1\relax%
          \ifnum\the\c@pgfplots@contour@edge@loop>3\relax% so for 4 or above?
            \pgfplots@loopcontourfalse%
          \else
            \pgfplots@loopcontourtrue%
          \fi%
      }{%
          \wcontour{10}{ 1.1.5 Run with EDGE=\c@pgfplots@contour@edge\space on loop: \the\c@pgfplots@contour@edge@loop
              and found edge \pgfplots@contour@get@macro\c@pgfplots@contour@edge{edge}}%
          \ifnum\c@pgfplots@contour@edge=#3\relax
            % the contour followed from the edge so we shouldn't go back
          \else
          % 
          % We check that if the contour lies on the edge and checks if it has been runned 
          % First we extract the edge corresponding point state.
            \let\pgfplots@contour@tmpB=\relax
            \pgfplots@contour@check@zero\pgfplots@contour@get@macro\c@pgfplots@contour@edge Z\to\pgfplots@contour@tmpA
            \ifnum\pgfplots@contour@tmpA=0
              \pgfmathparse{\c@pgfplots@contour@edge + 1}
              \pgfmathMod{\pgfmathresult}{4}
              \pgfmathint{\pgfmathresult}
              \pgfplots@contour@check@zero\pgfplots@contour@get@macro\pgfmathresult Z\to\pgfplots@contour@tmpA
              \ifnum\pgfplots@contour@tmpA=0
                \pgfplots@contour@calc@edge@matrix@elem#1,#2\of\c@pgfplots@contour@edge\to\pgfplots@contour@tmpB%
                \wcontour1{ 1.1.5b Hello \pgfplots@contour@tmpB\ifx\pgfplots@contour@tmpB\pgfplots@contour@runned@mark Has been runned for sure\else Go through\fi}
              \fi
            \fi
            % We have now checked for f[i] == 0.0 && f[(i+1)%4 == 0.0
            % TODO we havn't actually tested for the passed numbers are within range of the matrix size!
            \ifx\pgfplots@contour@tmpB\pgfplots@contour@runned@mark
              \wcontour1{ 1.1.6 The point has ALREADY been runned! (#1,#2)}
            \else
            % 
            % We now have to check if the current edge has a contour
              \pgfplots@contour@processfalse
              \ifnum\pgfplots@contour@get@macro\c@pgfplots@contour@edge{edge}=1
              % We are in the case of a contour on the exact point:
                \pgfplots@contour@processtrue
              \fi
              % If the point value is on the contour
              \pgfplots@contour@check@zero\pgfplots@contour@get@macro\c@pgfplots@contour@edge Z\to\pgfplots@contour@tmpC
              % reused down at "two cases". See where we "follow the contour" further down.
              \ifnum\pgfplots@contour@tmpC=0 
                \pgfplots@contour@processtrue
              \fi
              % the two above if statements checks whether we should process the contour, they are linked through a binary or check, in this case two ifs.
              \wcontour6{ 1.1.7 We are going to process: \pgfplots@contour@tmpC \ifpgfplots@contour@process TRUE \else FALSE \fi}
              \ifpgfplots@contour@process
              % First calculate the intersection point x[i] and y[i]
                \ifnum\pgfplots@contour@tmpC=0 % The contour is located on the point
                  \edef\pgfplots@contour@tmpA{\pgfplots@contour@get@macro\c@pgfplots@contour@edge{X}}
                  \edef\pgfplots@contour@tmpB{\pgfplots@contour@get@macro\c@pgfplots@contour@edge{Y}}
                \else % The contour is located in between two points and needs to be interpolated
                  \pgfplots@contour@interp@points\c@pgfplots@contour@edge\of X\to\pgfplots@contour@tmpA
                  \pgfplots@contour@interp@points\c@pgfplots@contour@edge\of Y\to\pgfplots@contour@tmpB
                \fi
                % 
                % Here we add the found contour x and y coordinate to the matrix! 
                % And advance counter
                % 
                \pgfplots@contour@add@contour@point(\pgfplots@contour@tmpA,\pgfplots@contour@tmpB)
                % 
                \c@pgfplots@contour@row@f=#1
                \c@pgfplots@contour@col@f=#2
                % Therefore we should follow the contour in!
                % 
                % There is two cases:
                % 1. The contour passes through the edge and NOT the points. (easy case)
                % 2. The contour passes through one of the points. (hard case)
                % First we find the next starting edge state:
                \ifnum\c@pgfplots@contour@edge=0
                  \c@pgfplots@contour@start@edge=2
                \else\ifnum\c@pgfplots@contour@edge=1
                  \c@pgfplots@contour@start@edge=3
                \else\ifnum\c@pgfplots@contour@edge=2
                  \c@pgfplots@contour@start@edge=0
                \else\ifnum\c@pgfplots@contour@edge=3
                  \c@pgfplots@contour@start@edge=1
                \fi\fi\fi\fi % end next edge check
                % Then we do case 1.:
                \ifnum\pgfplots@contour@tmpC=1 % so not passing through the corner point
                  \ifnum\c@pgfplots@contour@edge=0
                    \advance\c@pgfplots@contour@col@f by-1
                  \else\ifnum\c@pgfplots@contour@edge=1
                    \advance\c@pgfplots@contour@row@f by-1
                  \else\ifnum\c@pgfplots@contour@edge=2
                    \advance\c@pgfplots@contour@col@f by1
                  \else\ifnum\c@pgfplots@contour@edge=3
                    \advance\c@pgfplots@contour@row@f by1
                  \fi\fi\fi\fi % end edge contour check
                  \wcontour4{ 1.1.8 Easy case EDGE=\c@pgfplots@contour@edge (\the\c@pgfplots@contour@row@f,\the\c@pgfplots@contour@col@f)}
                \else % case number 2.:
                  \ifnum\c@pgfplots@contour@edge=0
                    \advance\c@pgfplots@contour@col@f by-1
                    \advance\c@pgfplots@contour@row@f by1
                  \else\ifnum\c@pgfplots@contour@edge=1
                    \advance\c@pgfplots@contour@col@f by-1
                    \advance\c@pgfplots@contour@row@f by-1
                  \else\ifnum\c@pgfplots@contour@edge=2
                    \advance\c@pgfplots@contour@col@f by1
                    \advance\c@pgfplots@contour@row@f by-1
                  \else\ifnum\c@pgfplots@contour@edge=3
                    \advance\c@pgfplots@contour@col@f by1
                    \advance\c@pgfplots@contour@row@f by1
                  \fi\fi\fi\fi % end edge contour check
                  \wcontour4{ 1.1.8 Hard case EDGE=\c@pgfplots@contour@edge (\the\c@pgfplots@contour@row@f,\the\c@pgfplots@contour@col@f)}
                \fi % the end of the two cases check. The \pgfplots@contour@follow@contours will now be redefined
                % The below checks ensure that we follow a contour which actually is permitted, i.e. the boundaries of the matrix is checked against the
                % followed matrix
                \wcontour{10}{ 1.1.9 Size check (\c@pgfplots@row@end,\c@pgfplots@col@end)}
%                \ifnum\c@pgfplots@contour@col@f=\c@pgfplots@col@end\else
                \ifnum\c@pgfplots@contour@col@f>\c@pgfplots@col@end\else
                \ifnum\c@pgfplots@contour@col@f<0\else
%                \ifnum\c@pgfplots@contour@row@f=\c@pgfplots@row@end\else
                \ifnum\c@pgfplots@contour@row@f>\c@pgfplots@row@end\else
                \ifnum\c@pgfplots@contour@row@f<0\else
                % 
                % We have to check that the thing we go into has not been runned
                \pgfplots@contour@read@runned(\the\c@pgfplots@contour@row@f,\the\c@pgfplots@contour@col@f)\to\pgfplots@contour@tmpA
%                \expandafter\let\expandafter\pgfplots@contour@tmpA\expandafter=\csname\string\pgfplots@contour@matrix@runned@\the\c@pgfplots@contour@row@f,\the\c@pgfplots@contour@col@f\endcsname%
                \wcontour{10}{Before last check: \meaning\pgfplots@contour@tmpA}
                \ifx\pgfplots@contour@tmpA\pgfplots@contour@runned@mark
                  % in this case do nothing as the next site has already been runned
                  \wcontour7{Found that it shouldn't be runned}
                \else
                  \edef\pgfplots@contour@follow@contours{%
                      % the rows and stuff needs to be expanded?
                      % TODO figure out if this is the correct way to do it.
                      % I find where the contour should be followed
                      % 1. add the following of the contour to this command
                      % 2. run the point till its end
                      % 3. if another contour should be followed it is added to the list of commands to be runned!
                      % this should work as the points will be marked runned and thus it will just jump out!
                      \ifx\pgfplots@contour@follow@contours\relax\else
                        \expandafter\unexpanded\expandafter{\pgfplots@contour@follow@contours}
                      \fi
                      \noexpand\wcontour1{Following in on contour (\the\c@pgfplots@contour@row@f,\the\c@pgfplots@contour@col@f) 
                          at edge \the\c@pgfplots@contour@start@edge}%
                      \noexpand\pgfplots@contour@read@runned(\the\c@pgfplots@contour@row@f,\the\c@pgfplots@contour@col@f)\noexpand\to\noexpand\pgfplots@contour@tmpA
                      \unexpanded{\ifx\pgfplots@contour@tmpA\pgfplots@contour@runned@mark\else}
                      \noexpand\pgfplots@contour@calc@linear@{\the\c@pgfplots@contour@row@f}{\the\c@pgfplots@contour@col@f}{\the\c@pgfplots@contour@start@edge}
                      % this is needed as otherwise it would end the call! not just on the final one! Every run has the possibility of redefining this!
                      \noexpand\fi
                      \noexpand\pgfplots@contour@follow@contours 
                  }
                  \wcontour7{Redefining the follow routine: \meaning\pgfplots@contour@follow@contours}
                \fi
                \fi\fi\fi\fi%\fi\fi % the end of the boundary check
              \fi % the end of the contour process
            \fi% the end of the current point runned check
          \fi% end of the contour edge check against the start edge #3
    }% this is the pgfplotsloop@contour, explains the indent
    \fi % end of \ifpgfplots@contour@process
}

%
% Calculates the edge states. There are 4 cases, where 2 of them are entwined:
%  1. The points are both above or both below the contour level. This yields > 0
%  2. The points are both equal to the contour level. This yields = 0
%  3. One is above the contour and one is below the contour. This yields < 0
%
% As we are interested in the case where we can find the contour we always only 
% consider option 2. and 3.
%
\def\pgfplots@contour@calc@edge@prod#1#2\to#3{%
    \pgfmathmultiply{\csname\string#1\endcsname}{\csname\string#2\endcsname}%
    \pgfmathparse{ifthenelse(\pgfmathresult>0,int(-1),ifthenelse(\pgfmathresult<0,int(1),int(0)))}%
    \wcontour{10}{\space\space\space Calculating and found \pgfmathresult =\csname\string#1\endcsname x\csname\string#2\endcsname}
    \expandafter\edef\csname\string#3\endcsname{\pgfmathresult}
}

%
% An interpolation calculator. It does so by having that the Z values already have subtracted the contour level
% so that the result gives the X or Y coordinate of the intersection on the contour.
% 
\def\pgfplots@contour@interp@points#1\of#2\to#3{%
    \ifnum#1=3
      \pgfmathparse{(\pgfplots@contour@get@macro{3}{#2} * abs(\pgfplots@contour@get@macro{0}{Z}) +
          \pgfplots@contour@get@macro{0}{#2} * abs(\pgfplots@contour@get@macro{3}{Z}) )
          / abs(\pgfplots@contour@get@macro{0}{Z} - \pgfplots@contour@get@macro{3}{Z})
      }%
    \else\ifnum#1=0
      \pgfmathparse{(\pgfplots@contour@get@macro{0}{#2} * abs(\pgfplots@contour@get@macro{1}{Z}) +
          \pgfplots@contour@get@macro{1}{#2} * abs(\pgfplots@contour@get@macro{0}{Z}) )
          / abs(\pgfplots@contour@get@macro{1}{Z} - \pgfplots@contour@get@macro{0}{Z})
      }%
    \else\ifnum#1=1
      \pgfmathparse{(\pgfplots@contour@get@macro{1}{#2} * abs(\pgfplots@contour@get@macro{2}{Z}) +
          \pgfplots@contour@get@macro{2}{#2} * abs(\pgfplots@contour@get@macro{1}{Z}) )
          / abs(\pgfplots@contour@get@macro{2}{Z} - \pgfplots@contour@get@macro{1}{Z})
      }%
    \else\ifnum#1=2
      \pgfmathparse{(\pgfplots@contour@get@macro{2}{#2} * abs(\pgfplots@contour@get@macro{3}{Z}) +
          \pgfplots@contour@get@macro{3}{#2} * abs(\pgfplots@contour@get@macro{2}{Z}) )
          / abs(\pgfplots@contour@get@macro{3}{Z} - \pgfplots@contour@get@macro{2}{Z})
      }%
    \fi\fi\fi\fi
    \edef#3{\pgfmathresult}
}

%
% Gets the namedef macro out
%
\def\pgfplots@contour@get@macro#1#2{\csname\string\pgfplots@contour@#1@#2\endcsname}

%
% Marks the point as runned
%
\def\pgfplots@contour@mark@runned(#1,#2){%
    \expandafter\let\csname\string\pgfplots@contour@matrix@runned@#1,#2\endcsname=\pgfplots@contour@runned@mark
}

%
% Read runned point
\def\pgfplots@contour@read@runned(#1,#2)\to#3{%
    \expandafter\let\expandafter#3\expandafter=\csname\string\pgfplots@contour@matrix@runned@#1,#2\endcsname
}

%
% This macro returns in #4 the corresponding element of the runned matrix
% for the case of certain edge values. A specific edge corresponds to certain points.
%
\def\pgfplots@contour@calc@edge@matrix@elem#1,#2\of#3\to#4{%
    \c@pgfplots@tmp=-1%\def\pgfmathresult{-1}
    \ifnum#3=0
      \c@pgfplots@tmp=#2
      \advance\c@pgfplots@tmp by -1
      \pgfplots@contour@read@runned(#1,\the\c@pgfplots@tmp)\to#4
    \else
    \ifnum#3=1
      \c@pgfplots@tmp=#1
      \advance\c@pgfplots@tmp by -1
      \pgfplots@contour@read@runned(\the\c@pgfplots@tmp,#2)\to#4
    \else
    \ifnum#3=2
      \c@pgfplots@tmp=#2
      \advance\c@pgfplots@tmp by 1
      \pgfplots@contour@read@runned(#1,\the\c@pgfplots@tmp)\to#4
    \else
    \ifnum#3=3
      \c@pgfplots@tmp=#1
      \advance\c@pgfplots@tmp by 1
      \pgfplots@contour@read@runned(\the\c@pgfplots@tmp,#2)\to#4
    \fi\fi\fi\fi% the end of num tests
    \ifnum\c@pgfplots@tmp<0
      \let#4=\pgfplots@contour@runned@mark%
    \fi
}

%
% Gets the macro from the matrix with an offset.
% So actually: \def#6{#5@#1+#3,#2+#4}
%
\def\pgfplots@matrix@get@offset#1,#2\offset#3,#4\of#5\to#6{%
    \c@pgfplots@tmp=#1
    \advance\c@pgfplots@tmp by #3
    \edef\pgfplots@contour@tmpA{\the\c@pgfplots@tmp}%
    \c@pgfplots@tmp=#2
    \advance\c@pgfplots@tmp by #4
    % \pgfmathadd{#2}{#4}
    % \pgfmathint{\pgfmathresult}
    \expandafter\edef\csname\string#6\endcsname{\noexpand\csname\string#5@\pgfplots@contour@tmpA,\the\c@pgfplots@tmp\endcsname}%
}

%
% Resets the \pgfplots@contour@matrix@runned
%
\def\pgfplots@contour@reset@runned{%
    \c@pgfplots@col=-1\relax%
    \c@pgfplots@row=0\relax%
    \pgfplotsloop{%
%        \wcontour{Hello \the\c@pgfplots@col}
        \ifnum\the\c@pgfplots@col=\c@pgfplots@col@end\relax
          \ifnum\the\c@pgfplots@row=\c@pgfplots@row@end\relax
            \pgfplotsloopcontinuefalse%
          \else
            \advance\c@pgfplots@row by1\relax
            \c@pgfplots@col=-1\relax
            \pgfplotsloopcontinuetrue
          \fi%
        \else%
          \pgfplotsloopcontinuetrue%
        \fi%
        \advance\c@pgfplots@col by1%
    }{%
%        \wcontour{Resetting runned MATRIX with (\c@pgfplots@row@end,\c@pgfplots@col@end) on column \the\c@pgfplots@row,\the\c@pgfplots@col}%
        \pgfutil@namelet{\string\pgfplots@contour@matrix@runned@\the\c@pgfplots@row,\the\c@pgfplots@col}{relax}%
%        \expandafter\gdef\csname\string\pgfplots@contour@matrix@runned@\the\c@pgfplots@row,\the\c@pgfplots@col\endcsname{\relax}%
    }%
}

%
% This routine returns 1 if the number it receives is different than 0, return 0 if 0.
%
\def\pgfplots@contour@check@zero#1\to#2{%
    \pgfmathparse{ifthenelse(#1==0.00,int(0),int(1))}
    \edef#2{\pgfmathresult}
}


\newif\ifpgfplots@loopcontour

% A loop construct which invokes '#1' and continues the loop if the
% boolean \ifpgfplotsloopcontinue is true and stops if it is false.
%
% #1: a statement which is expected to set \ifpgfplotsloopcontinue
% #2: the loop body.
\def\pgfplotsloop@contour#1#2{%
    #1\relax
    \ifpgfplots@loopcontour
      #2\relax
      \def\pgfplotsloop@contour@{\pgfplotsloop@contour{#1}{#2}}%
      \expandafter\pgfplotsloop@contour@
    \fi
}%

% This macro updates the list of current numbers in the contour list.
% Thus one updates the number of points in the previous "list" and adds the corresponding numbers.
\def\pgfplots@contour@start@contour{
    \pgfmathsubtract{\the\c@pgfplots@contour@cur}{\c@pgfplots@contour@cur@init}
    \pgfmathint{\pgfmathresult}
    \wcontour1{START A NEW CONTOUR! \the\c@pgfplots@contour@cur -\c@pgfplots@contour@cur@init =\pgfmathresult}
    \ifnum\pgfmathresult>1
      % We are in a legit case! There exists a contour and we can save it
      \expandafter\edef\csname\string\pgfplots@contour@matrix@points@\c@pgfplots@contour@cur@init,0\endcsname{\pgfplots@contour@curlevel}
      % Calculate the number of points on the contour
      \expandafter\edef\csname\string\pgfplots@contour@matrix@points@\c@pgfplots@contour@cur@init,1\endcsname{\pgfmathresult}
      % The below ensures that there will be one empty mark for when a new lvl is created.
      \advance\c@pgfplots@contour@cur by1\relax
      \edef\c@pgfplots@contour@cur@init{\the\c@pgfplots@contour@cur}
    \else
      \ifnum\pgfmathresult=1\relax
        % We have already added one contour point. This should be removed! So just step one point back!.
        \advance\c@pgfplots@contour@cur by-1\relax
      \fi
    \fi
}
% Add point to the current contour list
\def\pgfplots@contour@add@contour@point(#1,#2){
    \ifpgfplots@contour@first@point
      \pgfplots@contour@start@contour
      \pgfplots@contour@first@pointfalse
    \fi
    \advance\c@pgfplots@contour@cur by1
    \wcontour{15}{Contour point: adding (#1,#2), to \the\c@pgfplots@contour@cur}
    \expandafter\edef\csname\string\pgfplots@contour@matrix@points@\the\c@pgfplots@contour@cur,0\endcsname{#1}
    \expandafter\edef\csname\string\pgfplots@contour@matrix@points@\the\c@pgfplots@contour@cur,1\endcsname{#2}
}

\endinput
